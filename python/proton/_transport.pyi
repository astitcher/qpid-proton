from typing import (
    Callable,
    Optional,
    Type
)

from proton._condition import Condition
from proton._endpoints import Connection


class SASL:
    allow_insecure_mechs: bool

    @property
    def mech(self) -> Optional[str]: ...
    @property
    def outcome(self) -> Optional[int]: ...
    @property
    def user(self) -> Optional[str]: ...

    @staticmethod
    def extended() -> bool: ...

    def __init__(self, transport: Transport) -> None: ...
    def allowed_mechs(self, mechs: str) -> None: ...


class SSL:
    peer_hostname: Optional[str]

    @property
    def remote_subject(self) -> Optional[str]: ...

    @staticmethod
    def present() -> bool: ...

    @staticmethod
    def __new__(
        cls: Type[SSL],
        transport: Transport,
        domain: SSLDomain,
        session_details: Optional[SSLSessionDetails] = None
    ) -> SSL: ...
    def _check(self, err: int) -> int: ...
    def _get_cert_fingerprint_unknown_hash_alg(self) -> None: ...
    def _get_cert_subject_unknown_subfield(self) -> None: ...
    def cipher_name(self) -> Optional[str]: ...
    def get_cert_country(self) -> str: ...
    def get_cert_fingerprint(self, fingerprint_length: int, digest_name: int) -> Optional[str]: ...
    def get_cert_fingerprint_md5(self) -> str: ...
    def get_cert_fingerprint_sha1(self) -> str: ...
    def get_cert_fingerprint_sha256(self) -> str: ...
    def get_cert_fingerprint_sha512(self) -> str: ...
    def get_cert_locality_or_city(self) -> str: ...
    def get_cert_organization(self) -> str: ...
    def get_cert_organization_unit(self) -> str: ...
    def get_cert_state_or_province(self) -> str: ...
    def get_cert_subject(self) -> str: ...
    def get_cert_subject_subfield(self, subfield_name: int) -> Optional[str]: ...
    def protocol_name(self) -> Optional[str]: ...
    def resume_status(self) -> int: ...


class SSLDomain:
    MODE_CLIENT: int
    MODE_SERVER: int
    VERIFY_PEER: int
    VERIFY_PEER_NAME: int
    ANONYMOUS_PEER: int

    def __del__(self) -> None: ...
    def __init__(self, mode: int) -> None: ...
    def _check(self, err: int) -> int: ...
    def allow_unsecured_client(self) -> int: ...
    def set_credentials(self, cert_file: str, key_file: str, password: str) -> int: ...
    def set_peer_authentication(self, verify_mode: int, trusted_CAs: Optional[str] = None) -> int: ...
    def set_trusted_ca_db(self, certificate_db: str) -> int: ...


class SSLSessionDetails:
    def __init__(self, session_id: str) -> None: ...
    def get_session_id(self) -> str: ...


class TraceAdapter:
    def __init__(self, tracer: Callable) -> None: ...


class Transport:
    channel_max: int
    idle_timeout: float
    max_frame_size: int
    tracer: Optional[Callable]

    @property
    def authenticated(self) -> bool: ...
    @property
    def closed(self) -> bool: ...
    @property
    def condition(self) -> Optional[Condition]: ...
    @property
    def encrypted(self) -> bool: ...
    @property
    def frames_input(self) -> int: ...
    @property
    def frames_output(self) -> int: ...
    @property
    def remote_idle_timeout(self) -> float: ...
    @property
    def remote_max_frame_size(self) -> int: ...
    @property
    def user(self) -> Optional[str]: ...

    def _check(self, err: int) -> int: ...
    def _init(self) -> None: ...
    def bind(self, connection: Connection) -> None: ...
    def capacity(self) -> int: ...
    def close_head(self) -> None: ...
    def close_tail(self) -> None: ...
    def log(self, message: str) -> None: ...
    def peek(self, size: int) -> Optional[bytes]: ...
    def pending(self) -> int: ...
    def pop(self, size: int) -> None: ...
    def push(self, binary: bytes) -> None: ...
    def require_auth(self, bool: bool) -> None: ...
    def sasl(self) -> SASL: ...
    def ssl(
        self,
        domain: Optional[SSLDomain] = None,
        session_details: Optional[SSLSessionDetails] = None
    ) -> SSL: ...
    def tick(self, now: float) -> float: ...
    def trace(self, n: int) -> None: ...
    def unbind(self) -> None: ...
