from typing import (
    Any,
    Callable,
    Iterable,
    List,
    Optional,
    Union,
)

from uuid import UUID

from proton._delivery import Delivery
from proton._endpoints import Connection, Session, Link, Receiver, Sender
from proton._events import EventBase, Event
from proton._selectable import Selectable
from proton._transport import SSLDomain
from proton._url import Url


def _apply_link_options(options: None, link: Union[Receiver, Sender]) -> None: ...


def _create_session(connection: Connection, handler: None = None) -> Session: ...


def _millis2timeout(millis: int) -> float: ...


def _timeout2millis(secs: float) -> int: ...


def generate_uuid() -> UUID: ...


class Acceptor:
    def close(self) -> None: ...


class ApplicationEvent(EventBase):
    def __init__(
        self,
        typename: str,
        connection: Optional[Connection] = None,
        session: Optional[Session] = None,
        link: Optional[Link] = None,
        delivery: Optional[Delivery] = None,
        subject: Any = None
    ) -> None: ...


class Backoff:
    def __init__(self) -> None: ...
    def reset(self) -> None: ...


class Handler: ...


class Connector(Handler):
    address: Iterable[Url]
    reconnect: Any

    def __init__(self, connection: Connection) -> None: ...
    def _connect(self, connection: Connection, reactor: Container) -> None: ...
    def on_connection_local_open(self, event: Event) -> None: ...
    def on_connection_remote_open(self, event: Event) -> None: ...
    def on_transport_closed(self, event: Event) -> None: ...
    def on_transport_tail_closed(self, event: Event) -> None: ...


class EventInjector:
    def __init__(self) -> None: ...
    def trigger(self, event: ApplicationEvent) -> None: ...


class GlobalOverrides:
    def __init__(self, base: Handler) -> None: ...
    def _override(self, event: Event) -> Optional[bool]: ...
    def on_unhandled(self, name: str, event: Event) -> None: ...


class Reactor:
    def __init__(self, *handlers: Any, **kwargs: Any) -> None: ...
    def _init(self) -> None: ...
    def _check_errors(self) -> None: ...
    def _get_global(self) -> Handler: ...
    def _get_handler(self) -> Handler: ...
    def _get_timeout(self) -> float: ...
    def _set_global(self, handler: Any) -> None: ...
    def _set_handler(self, handler: Any) -> None: ...
    def _set_timeout(self, secs: float) -> None: ...
    def acceptor(self, host: str, port: Union[int, str], handler: Any = None) -> Acceptor: ...
    def connection(self, handler: Any = None) -> Connection: ...
    def get_connection_address(self, connection: Connection) -> str: ...
    def mark(self) -> int: ...
    def on_error_delegate(self) -> Callable: ...
    def process(self) -> bool: ...
    def run(self) -> None: ...
    def schedule(self, delay: int, task: Any) -> Task: ...
    def selectable(self, handler: Any = None) -> Selectable: ...
    def set_connection_host(self, connection: Connection, host: str, port: str) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def wakeup(self) -> None: ...
    def yield_(self) -> None: ...

    class ErrorDelegate:
        def __init__(self, reactor: Container) -> None: ...


class Container(Reactor):
    def __init__(self, *handlers: Any, **kwargs: Any) -> None: ...
    def _get_id(self, container: str, remote: None, local: None) -> str: ...
    def _get_session(self, context: Connection) -> Session: ...
    def connect(
        self,
        url: Optional[Union[Url, str]] = None,
        urls: Optional[Urls] = None,
        address: Optional[str] = None,
        handler: Any = None,
        reconnect: Optional[bool] = None,
        heartbeat: Optional[float] = None,
        ssl_domain: Optional[SSLDomain] = None,
        **kwargs: Any
    ) -> Connection: ...
    def create_receiver(
        self,
        context: Connection,
        source: None = None,
        target: None = None,
        name: None = None,
        dynamic: bool = False,
        handler: Any = None,
        options: None = None
    ) -> Receiver: ...
    def create_sender(
        self,
        context: Connection,
        target: None = None,
        source: None = None,
        name: None = None,
        handler: None = None,
        tags: None = None,
        options: None = None
    ) -> Sender: ...
    def listen(self, url: str, ssl_domain: Optional[SSLDomain] = None) -> Acceptor: ...


class SSLConfig:
    def __init__(self) -> None: ...


class SessionPerConnection:
    def __init__(self) -> None: ...
    def session(self, connection: Connection) -> Session: ...


class Task:
    def _init(self) -> None: ...
    def cancel(self) -> None: ...


class Urls:
    def __init__(self, values: List[Union[Url, str]]) -> None: ...
    def next(self) -> Url: ...

class LinkOption: ...
class ReceiverOption(LinkOption): ...
class SenderOption(LinkOption): ...
class AtLeastOnce(LinkOption): ...
class AtMostOnce(LinkOption): ...
class DynamicNodeProperties(LinkOption): ...
class Filter(ReceiverOption): ...
class Selector(Filter): ...
class DurableSubscription(ReceiverOption): ...
class Copy(ReceiverOption): ...
class Move(ReceiverOption): ...