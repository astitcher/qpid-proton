from typing import (
    Dict,
    Optional,
    Union,
    overload
)

from cproton import pn_connection_t, pn_session_t, pn_link_t, pn_sender_t, pn_receiver_t, pn_terminus_t

from proton._condition import Condition
from proton._data import (
    Array,
    Data,
    symbol,
)
from proton._delivery import Delivery
from proton._events import Collector, Handler
from proton._message import Message
from proton._transport import Transport
from proton._url import Url
from proton._wrapper import Wrapper

class Endpoint:
    LOCAL_UNINIT: int
    REMOTE_UNINIT: int
    LOCAL_ACTIVE: int
    REMOTE_ACTIVE: int
    LOCAL_CLOSED: int
    REMOTE_CLOSED: int

    def _get_handler(self) -> Handler: ...
    def _init(self) -> None: ...
    def _set_handler(self, handler: object) -> None: ...
    def _update_cond(self) -> None: ...
    @property
    def remote_condition(self) -> Optional[Condition]: ...


class Connection(Wrapper, Endpoint):
    container: Optional[str]
    hostname: Optional[str]
    password: Optional[str]
    user: Optional[str]
    url: Optional[str]]

    @property
    def remote_container(self) -> Optional[str]: ...
    @property
    def remote_desired_capabilities(self) -> Optional[Array]: ...
    @property
    def remote_hostname(self) -> Optional[str]: ...
    @property
    def remote_offered_capabilities(self) -> Optional[Array]: ...
    @property
    def remote_properties(self) -> Optional[Dict[symbol, symbol]]: ...
    @property
    def state(self) -> int: ...
    @property
    def transport(self) -> Transport: ...
    @property
    def work_head(self) -> Optional[Delivery]: ...

    @staticmethod
    def wrap(impl: pn_connection_t) -> Connection: ...

    def _init(self) -> None: ...

    def close(self) -> None: ...
    def collect(self, collector: Collector) -> None: ...
    def free(self) -> None: ...
    def link_head(self, mask: int) -> Receiver: ...
    def open(self) -> None: ...
    def session(self) -> Session: ...
    def session_head(self, mask: int) -> Optional[Session]: ...

class Link(Wrapper, Endpoint):
    SND_UNSETTLED: int
    SND_SETTLED: int
    SND_MIXED: int
    RCV_FIRST: int
    RCV_SECOND: int

    def _check(self, err: int) -> int: ...
    def _get_max_message_size(self) -> int: ...
    def _get_rcv_settle_mode(self) -> int: ...
    def _get_snd_settle_mode(self) -> int: ...
    def _set_max_message_size(self, mode: int) -> None: ...
    def _set_rcv_settle_mode(self, mode: int) -> None: ...
    def _set_snd_settle_mode(self, mode: int) -> None: ...
    def advance(self) -> bool: ...
    def close(self) -> None: ...
    @property
    def credit(self) -> int: ...
    @property
    def current(self) -> Optional[Delivery]: ...
    def delivery(self, tag: str) -> Delivery: ...
    def detach(self) -> None: ...
    def drained(self) -> int: ...
    def free(self) -> None: ...
    @property
    def is_receiver(self) -> bool: ...
    @property
    def name(self) -> str: ...
    def next(self, mask: int) -> Optional[Sender]: ...
    def open(self) -> None: ...
    @property
    def queued(self) -> int: ...
    @property
    def remote_max_message_size(self) -> int: ...
    @property
    def remote_rcv_settle_mode(self) -> int: ...
    @property
    def remote_snd_settle_mode(self) -> int: ...
    @property
    def remote_source(self) -> Terminus: ...
    @property
    def remote_target(self) -> Terminus: ...
    @property
    def session(self) -> Session: ...
    @property
    def source(self) -> Terminus: ...
    @property
    def state(self) -> int: ...
    @property
    def target(self) -> Terminus: ...
    @property
    def unsettled(self) -> int: ...
    @staticmethod
    def wrap(impl: pn_link_t) -> Link: ...


class Receiver(Link):
    def drain(self, n: int) -> None: ...
    def draining(self) -> bool: ...
    def flow(self, n: int) -> None: ...
    def recv(self, limit: int) -> Optional[bytes]: ...


class Sender(Link):
    def delivery_tag(self) -> str: ...
    def send(
        self,
        obj: Union[bytes, Message],
        tag: None = None
    ) -> Union[int, Delivery]: ...
    def stream(self, data: bytes) -> int: ...


class Session(Wrapper, Endpoint):
    def _get_incoming_capacity(self) -> int: ...
    def _get_outgoing_window(self) -> int: ...
    def _set_incoming_capacity(self, capacity: int) -> None: ...
    def _set_outgoing_window(self, window: int) -> None: ...
    def close(self) -> None: ...
    @property
    def connection(self) -> Connection: ...
    def free(self) -> None: ...
    @property
    def incoming_bytes(self) -> int: ...
    def open(self) -> None: ...
    @property
    def outgoing_bytes(self) -> int: ...
    def receiver(self, name: str) -> Receiver: ...
    def sender(self, name: str) -> Sender: ...
    @property
    def state(self) -> int: ...
    @staticmethod
    def wrap(impl: None) -> None: ...


class Terminus:
    UNSPECIFIED: int
    SOURCE: int
    TARGET: int
    COORDINATOR: int
    NONDURABLE: int
    CONFIGURATION: int
    DELIVERIES: int
    DIST_MODE_UNSPECIFIED: int
    DIST_MODE_COPY: int
    DIST_MODE_MOVE: int
    EXPIRE_WITH_LINK: int
    EXPIRE_WITH_SESSION: int
    EXPIRE_WITH_CONNECTION: int
    EXPIRE_NEVER: int

    def _check(self, err: int) -> int: ...
    def _get_address(self) -> Optional[str]: ...
    def _get_distribution_mode(self) -> int: ...
    def _get_durability(self) -> int: ...
    def _get_expiry_policy(self) -> int: ...
    def _get_timeout(self) -> int: ...
    def _get_type(self) -> int: ...
    def _is_dynamic(self) -> bool: ...
    def _set_address(self, address: str) -> None: ...
    def _set_distribution_mode(self, mode: int) -> None: ...
    def _set_dynamic(self, dynamic: bool) -> None: ...
    def _set_timeout(self, seconds: int) -> None: ...
    def _set_type(self, type: int) -> None: ...
    @property
    def capabilities(self) -> Data: ...
    def copy(self, src: Terminus) -> None: ...
    @property
    def filter(self) -> Data: ...
    @property
    def outcomes(self) -> Data: ...
    @property
    def properties(self) -> Data: ...
